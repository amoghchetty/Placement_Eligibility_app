# -*- coding: utf-8 -*-
"""Placement eligibility app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XRohKhtU7vstSOS4UqmSTyKd30YAPGja
"""

pip install streamlit faker pandas sqlalchemy

## ----- creating fake data ------
import pandas as pd
import random
from faker import Faker

class StudentTable:
    def __init__(self, students_table):
        self.students_table = students_table
        self.fake = Faker()
        self.students = []

    def generate_students(self):
        for i in range(1, self.students_table + 1):
            enrollment_year = random.choice([2020,2025])
            student = {
                "student_id": i,
                "name": self.fake.name(),
                "age": random.randint(18, 30),
                "gender": random.choice(["Male", "Female", "Other"]),
                "email": self.fake.email(),
                "phone": self.fake.phone_number(),
                "enrollment_year": enrollment_year,
                "course_batch": f"Batch-{random.randint(1, 10)}",
                "city": self.fake.city(),
                "graduation_year": enrollment_year + 4
            }
            self.students.append(student)
        return pd.DataFrame(self.students)

student_table = StudentTable(30)
students_df = student_table.generate_students()

students_df.tail()

class Programming:
    def __init__(self, student_id):
        self.programming_id = student_id
        self.student_id = student_id
        self.language = random.choice(['Python','SQL'])
        self.problems_solved = random.randint(0, 300)
        self.assessments_completed = random.randint(0, 5)
        self.mini_projects = random.randint(0, 3)
        self.certifications_earned = random.randint(0, 2)
        self.latest_project_score = random.randint(0, 100)

    def to_dict(self):
        return self.__dict__


programming_data = [Programming(i).to_dict() for i in range(1, 16)]
programming_df = pd.DataFrame(programming_data)
programming_df.head()

class SoftSkills:
    def __init__(self, student_id):
        self.soft_skill_id = student_id
        self.student_id = student_id
        self.communication = random.randint(40, 100)
        self.teamwork = random.randint(40, 100)
        self.presentation = random.randint(40, 100)
        self.leadership = random.randint(40, 100)
        self.critical_thinking = random.randint(40, 100)
        self.interpersonal_skills = random.randint(40, 100)

    def to_dict(self):
        return self.__dict__


soft_skills_data = [SoftSkills(i).to_dict() for i in range(1, 16)]
soft_skills_df = pd.DataFrame(soft_skills_data)
soft_skills_df.head()

class Programming:
    def __init__(self, student_id):
        self.programming_id = student_id
        self.student_id = student_id
        self.language = random.choice(['Python','SQL'])
        self.problems_solved = random.randint(0, 300)
        self.assessments_completed = random.randint(0, 5)
        self.mini_projects = random.randint(0, 3)
        self.certifications_earned = random.randint(0, 2)
        self.latest_project_score = random.randint(0, 100)

    def to_dict(self):
        return self.__dict__


programming_data = [Programming(i).to_dict() for i in range(1, 16)]
programming_df = pd.DataFrame(programming_data)
programming_df.head()

class Placement_table:
    def __init__(self, students_df):
        self.students_df = students_df
        self.fake = Faker()
        self.placements = []

    def generate_placements(self):
        for _, row in self.students_df.iterrows():
            mock_score = random.randint(70, 100)
            project_exp = random.randint(2, 5)

            placement_status = "Not Eligible"
            if mock_score > 75 and project_exp > 2:
                placement_status = "Eligible"

            if random.random() < 0.25:
                placement_status = "Placed"

            placement_info = {
                "placement_id": self.fake.unique.random_int(min=1000, max=9999),
                "student_id": row['student_id'],
                "mock_test_score": mock_score,
                "project_experience": project_exp,
                "placement_status": placement_status,
                "company_name": None,
                "package_lpa": None,
                "interview_rounds": random.randint(2, 5),
                "date_of_placement": None
            }

            if placement_status == "Placed":
                placement_info["company_name"] = self.fake.company()
                placement_info["package_lpa"] = round(random.uniform(4.0, 18.0), 2)
                placement_info["date_of_placement"] = self.fake.date_between(start_date='-60d', end_date='today')

            elif placement_status == "Eligible":
                placement_info["company_name"] = self.fake.company()
                placement_info["date_of_placement"] = self.fake.date_between(start_date='today', end_date='+45d')

            elif placement_status == "Not Eligible":
                placement_info["company_name"] = None
                placement_info["package_lpa"] = None
                placement_info["date_of_placement"] = None

            self.placements.append(placement_info)

        return pd.DataFrame(self.placements)

placement_generator = Placement_table(students_df)
placements_df = placement_generator.generate_placements()
placements_df.head()

## ---- create new database----
import sqlite3
conn = sqlite3.connect("student.db")
cursor = conn.cursor()

cursor.execute("DROP TABLE IF EXISTS Placements")
cursor.execute("DROP TABLE IF EXISTS SoftSkills")
cursor.execute("DROP TABLE IF EXISTS Programming")
cursor.execute("DROP TABLE IF EXISTS Students")

##----- Create Students table-----
cursor.execute('''
CREATE TABLE IF NOT EXISTS students (
    student_id INTEGER PRIMARY KEY,
    name TEXT,
    age INTEGER,
    gender TEXT,
    email TEXT,
    phone TEXT,
    enrollment_year INTEGER,
    course_batch INTEGER,
    city TEXT,
    graduation_year INTEGER
    )
    ''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS Programming (
    programming_id INTEGER PRIMARY KEY,
    student_id INTEGER,
    language TEXT,
    problems_solved INTEGER,
    assessments_completed INTEGER,
    mini_projects INTEGER,
    certifications_earned INTEGER,
    latest_project_score INTEGER,
    FOREIGN KEY (student_id) REFERENCES students (student_id)
    )
    ''')

cursor.execute("""
CREATE TABLE IF NOT EXISTS SoftSkills (
soft_skill_id TEXT PRIMARY KEY,
student_id INTEGER,
communication INTEGER,
teamwork INTEGER,
presentation INTEGER,
leadership INTEGER,
critical_thinking INTEGER,
interpersonal_skills INTEGER,
FOREIGN KEY(student_id) REFERENCES Students(student_id)
)
""")

cursor.execute("""
CREATE TABLE IF NOT EXISTS Placements (
placement_id INTEGER PRIMARY KEY,
student_id INTEGER,
mock_interview_score INTEGER,
internships_completed INTEGER,
placement_status TEXT,
company_name TEXT,
placement_package REAL,
interview_rounds_cleared INTEGER,
placement_date TEXT,
FOREIGN KEY(student_id) REFERENCES Students(student_id)
)
""")

students_df.to_sql('students', conn, if_exists='replace', index = False)
programming_df.to_sql('Programming', conn, if_exists='replace', index = False)
soft_skills_df.to_sql('SoftSkills', conn, if_exists='replace', index = False)
placements_df.to_sql('Placements', conn, if_exists='replace', index = False)

conn.commit()
conn.close()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import sqlite3
# 
# 
# conn = sqlite3.connect("student.db")
# 
# 
# students_df = pd.read_sql_query("SELECT * FROM students", conn)
# placements_df = pd.read_sql_query("SELECT * FROM Placements", conn)
# programming_df = pd.read_sql_query("SELECT * FROM Programming", conn)
# soft_skills_df = pd.read_sql_query("SELECT * FROM SoftSkills", conn)
# 
# 
# placements_df['placement_status'] = placements_df['placement_status'].astype(str)
# placed_df = placements_df[placements_df['placement_status'].str.lower() == 'placed']
# 
# 
# menu = st.sidebar.radio("Dashboard", [
#     "Overview",
#     "Search & Filter",
#     "Placement Reports",
#     "SQL Queries",
#     "Creator Info"
# ])
# 
# 
# if menu == "Overview":
#     st.title(" Placement Eligibility Portal")
#     st.markdown("""
#         Welcome to the Placement Eligibility Portal.
#         This project provides insights on student performance, soft skills, and placement outcomes.
#         The data is generated using Faker and stored in an SQLite database.
# 
#         ###  DATABASE USED:
#         `students.db`
#     """)
#     st.markdown("**Sections:**")
#     st.markdown("-  Search & Filter")
#     st.markdown("-  Placement Reports")
#     st.markdown("-  SQL Queries")
# 
# elif menu == "Search & Filter":
#     st.title("Search & Filter Students by Skills & Placement Status")
# 
#     search_name = st.text_input("Search by Student Name")
# 
#     selected_project_exp = st.selectbox("Project experience", options=["ALL"] + list(range(1, 6)))
# 
#     score_range_option = st.selectbox("Mock Test Score", options=["All", "< 75", ">= 75"])
# 
#     merged_df = pd.merge(students_df, placements_df, on="student_id", how="left")
# 
#     if search_name:
#         merged_df = merged_df[merged_df['name'].str.contains(search_name, case=False)]
# 
#     if selected_project_exp != "ALL":
#         merged_df = merged_df[merged_df['project_experience'] == selected_project_exp]
# 
#     if score_range_option == "< 75":
#         merged_df = merged_df[merged_df['mock_test_score'] < 75]
#     elif score_range_option == ">= 75":
#         merged_df = merged_df[merged_df['mock_test_score'] >= 75]
# 
#     st.dataframe(merged_df[[
#         'student_id', 'name', 'mock_test_score', 'project_experience',
#         'placement_status', 'company_name', 'package_lpa'
#     ]])
# 
# 
# elif menu == "Placement Reports":
#     st.title(" Placement Reports")
# 
#     col1, col2 = st.columns(2)
#     col1.metric("Total Placed Students", len(placed_df))
#     col2.metric("Average Package (LPA)", round(placed_df['package_lpa'].mean(), 2) if not placed_df.empty else 0)
# 
#     st.subheader("Top Companies Hiring")
#     if not placed_df.empty:
#         top_companies = placed_df['company_name'].value_counts().head(10).reset_index()
#         top_companies.columns = ['Company', 'Count']
#         st.dataframe(top_companies)
#     else:
#         st.info("No placed students to show companies.")
# 
#     st.subheader("Package Summary")
#     if not placed_df.empty:
#         st.dataframe(pd.DataFrame({
#             'Highest Package (LPA)': [placed_df['package_lpa'].max()],
#             'Lowest Package (LPA)': [placed_df['package_lpa'].min()]
#         }))
#     else:
#         st.info("No package data available.")
# 
#     st.subheader("Placement Status Summary")
#     st.dataframe(placements_df['placement_status'].value_counts().reset_index().rename(columns={'index': 'Status', 'placement_status': 'Count'}))
# 
# 
# elif menu == "SQL Queries":
#     st.title(" SQL Insights")
# 
#     query_options = {
#         "1. Total Students": "SELECT COUNT(*) AS total_students FROM students",
#         "2. Average Age": "SELECT AVG(age) AS average_age FROM students",
#         "3. City-wise Student Count": "SELECT city, COUNT(*) as count FROM students GROUP BY city ORDER BY count DESC",
#         "4. Gender Distribution": "SELECT gender, COUNT(*) as count FROM students GROUP BY gender",
#         "5. Batch-wise Average Age": "SELECT course_batch, AVG(age) as avg_age FROM students GROUP BY course_batch",
#         "6. Top 5 Placements by Package": """
#             SELECT name, company_name, package_lpa
#             FROM students s
#             JOIN Placements p ON s.student_id = p.student_id
#             WHERE p.placement_status = 'Placed'
#             ORDER BY package_lpa DESC
#             LIMIT 5
#         """,
#         "7. Programming Language Popularity": "SELECT language, COUNT(*) as count FROM Programming GROUP BY language",
#         "8. Avg Problems Solved per Batch": """
#             SELECT s.course_batch, AVG(p.problems_solved) as avg_solved
#             FROM students s
#             JOIN Programming p ON s.student_id = p.student_id
#             GROUP BY s.course_batch
#         """,
#         "9. Soft Skills Averages": """
#             SELECT
#                 ROUND(AVG(communication), 1) AS communication,
#                 ROUND(AVG(teamwork), 1) AS teamwork,
#                 ROUND(AVG(presentation), 1) AS presentation,
#                 ROUND(AVG(leadership), 1) AS leadership,
#                 ROUND(AVG(critical_thinking), 1) AS critical_thinking
#             FROM SoftSkills
#         """,
#         "10. Placement Status Count": "SELECT placement_status, COUNT(*) FROM Placements GROUP BY placement_status"
#     }
# 
#     selected_query = st.selectbox("Select a Query to View Results", list(query_options.keys()))
# 
#     try:
#         result_df = pd.read_sql_query(query_options[selected_query], conn)
#         st.dataframe(result_df)
#     except Exception as e:
#         st.error(f"Error running query: {e}")
# 
# 
# elif menu == "Creator Info":
#     st.title(" Creator Info")
# 
#     st.markdown("""
#     ## About the Creator
# 
#     **DEVELOPED BY:** Amogh Chetty
# 
#     SKILLS:Python,SQL,Streamlit
# 
#     """)
# 
# 
# 
# 
#

!pip install streamlit pyngrok

from pyngrok import ngrok, conf

# Paste your ngrok authtoken here (from your ngrok dashboard)
conf.get_default().auth_token = "2ym27oZIE8kYiqXDPSnwuj6FkfW_Vx9NSExuocKoMsdM9Anz"

# Run Streamlit app in background
!streamlit run app.py &> /dev/null &

# Connect ngrok (correct port as integer)
public_url = ngrok.connect(8501)

print("✅ Streamlit app is live at:", public_url)

